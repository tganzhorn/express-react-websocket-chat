{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/tobias/Documents/test-app/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/home/tobias/Documents/test-app/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/tobias/Documents/test-app/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Client = void 0;\n\nvar socket_io_parser_1 = require(\"socket.io-parser\");\n\nvar debugModule = require(\"debug\");\n\nvar url = require(\"url\");\n\nvar debug = debugModule(\"socket.io:client\");\n\nvar Client = /*#__PURE__*/function () {\n  /**\n   * Client constructor.\n   *\n   * @param server instance\n   * @param conn\n   * @package\n   */\n  function Client(server, conn) {\n    _classCallCheck(this, Client);\n\n    this.sockets = new Map();\n    this.nsps = new Map();\n    this.server = server;\n    this.conn = conn;\n    this.encoder = server.encoder;\n    this.decoder = new server._parser.Decoder();\n    this.id = conn.id;\n    this.setup();\n  }\n  /**\n   * @return the reference to the request that originated the Engine.IO connection\n   *\n   * @public\n   */\n\n\n  _createClass(Client, [{\n    key: \"request\",\n    get: function get() {\n      return this.conn.request;\n    }\n    /**\n     * Sets up event listeners.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"setup\",\n    value: function setup() {\n      var _this = this;\n\n      this.onclose = this.onclose.bind(this);\n      this.ondata = this.ondata.bind(this);\n      this.onerror = this.onerror.bind(this);\n      this.ondecoded = this.ondecoded.bind(this); // @ts-ignore\n\n      this.decoder.on(\"decoded\", this.ondecoded);\n      this.conn.on(\"data\", this.ondata);\n      this.conn.on(\"error\", this.onerror);\n      this.conn.on(\"close\", this.onclose);\n      this.connectTimeout = setTimeout(function () {\n        if (_this.nsps.size === 0) {\n          debug(\"no namespace joined yet, close the client\");\n\n          _this.close();\n        } else {\n          debug(\"the client has already joined a namespace, nothing to do\");\n        }\n      }, this.server._connectTimeout);\n    }\n    /**\n     * Connects a client to a namespace.\n     *\n     * @param {String} name - the namespace\n     * @param {Object} auth - the auth parameters\n     * @private\n     */\n\n  }, {\n    key: \"connect\",\n    value: function connect(name) {\n      var _this2 = this;\n\n      var auth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.server._nsps.has(name)) {\n        debug(\"connecting to namespace %s\", name);\n        return this.doConnect(name, auth);\n      }\n\n      this.server._checkNamespace(name, auth, function (dynamicNspName) {\n        if (dynamicNspName) {\n          debug(\"dynamic namespace %s was created\", dynamicNspName);\n\n          _this2.doConnect(name, auth);\n        } else {\n          debug(\"creation of namespace %s was denied\", name);\n\n          _this2._packet({\n            type: socket_io_parser_1.PacketType.CONNECT_ERROR,\n            nsp: name,\n            data: {\n              message: \"Invalid namespace\"\n            }\n          });\n        }\n      });\n    }\n    /**\n     * Connects a client to a namespace.\n     *\n     * @param name - the namespace\n     * @param {Object} auth - the auth parameters\n     *\n     * @private\n     */\n\n  }, {\n    key: \"doConnect\",\n    value: function doConnect(name, auth) {\n      var _this3 = this;\n\n      var nsp = this.server.of(name);\n\n      var socket = nsp._add(this, auth, function () {\n        _this3.sockets.set(socket.id, socket);\n\n        _this3.nsps.set(nsp.name, socket);\n\n        if (_this3.connectTimeout) {\n          clearTimeout(_this3.connectTimeout);\n          _this3.connectTimeout = undefined;\n        }\n      });\n    }\n    /**\n     * Disconnects from all namespaces and closes transport.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_disconnect\",\n    value: function _disconnect() {\n      var _iterator = _createForOfIteratorHelper(this.sockets.values()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var socket = _step.value;\n          socket.disconnect();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this.sockets.clear();\n      this.close();\n    }\n    /**\n     * Removes a socket. Called by each `Socket`.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_remove\",\n    value: function _remove(socket) {\n      if (this.sockets.has(socket.id)) {\n        var nsp = this.sockets.get(socket.id).nsp.name;\n        this.sockets.delete(socket.id);\n        this.nsps.delete(nsp);\n      } else {\n        debug(\"ignoring remove for %s\", socket.id);\n      }\n    }\n    /**\n     * Closes the underlying connection.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (\"open\" === this.conn.readyState) {\n        debug(\"forcing transport close\");\n        this.conn.close();\n        this.onclose(\"forced server close\");\n      }\n    }\n    /**\n     * Writes a packet to the transport.\n     *\n     * @param {Object} packet object\n     * @param {Object} opts\n     * @private\n     */\n\n  }, {\n    key: \"_packet\",\n    value: function _packet(packet, opts) {\n      opts = opts || {};\n      var self = this; // this writes to the actual connection\n\n      function writeToEngine(encodedPackets) {\n        // TODO clarify this.\n        if (opts.volatile && !self.conn.transport.writable) return;\n\n        for (var i = 0; i < encodedPackets.length; i++) {\n          self.conn.write(encodedPackets[i], {\n            compress: opts.compress\n          });\n        }\n      }\n\n      if (\"open\" === this.conn.readyState) {\n        debug(\"writing packet %j\", packet);\n\n        if (!opts.preEncoded) {\n          // not broadcasting, need to encode\n          writeToEngine(this.encoder.encode(packet)); // encode, then write results to engine\n        } else {\n          // a broadcast pre-encodes a packet\n          writeToEngine(packet);\n        }\n      } else {\n        debug(\"ignoring packet write %j\", packet);\n      }\n    }\n    /**\n     * Called with incoming transport data.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"ondata\",\n    value: function ondata(data) {\n      // try/catch is needed for protocol violations (GH-1880)\n      try {\n        this.decoder.add(data);\n      } catch (e) {\n        this.onerror(e);\n      }\n    }\n    /**\n     * Called when parser fully decodes a packet.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"ondecoded\",\n    value: function ondecoded(packet) {\n      if (socket_io_parser_1.PacketType.CONNECT === packet.type) {\n        if (this.conn.protocol === 3) {\n          var parsed = url.parse(packet.nsp, true);\n          this.connect(parsed.pathname, parsed.query);\n        } else {\n          this.connect(packet.nsp, packet.data);\n        }\n      } else {\n        var socket = this.nsps.get(packet.nsp);\n\n        if (socket) {\n          process.nextTick(function () {\n            socket._onpacket(packet);\n          });\n        } else {\n          debug(\"no socket for namespace %s\", packet.nsp);\n        }\n      }\n    }\n    /**\n     * Handles an error.\n     *\n     * @param {Object} err object\n     * @private\n     */\n\n  }, {\n    key: \"onerror\",\n    value: function onerror(err) {\n      var _iterator2 = _createForOfIteratorHelper(this.sockets.values()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var socket = _step2.value;\n\n          socket._onerror(err);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      this.conn.close();\n    }\n    /**\n     * Called upon transport close.\n     *\n     * @param reason\n     * @private\n     */\n\n  }, {\n    key: \"onclose\",\n    value: function onclose(reason) {\n      debug(\"client close with reason %s\", reason); // ignore a potential subsequent `close` event\n\n      this.destroy(); // `nsps` and `sockets` are cleaned up seamlessly\n\n      var _iterator3 = _createForOfIteratorHelper(this.sockets.values()),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var socket = _step3.value;\n\n          socket._onclose(reason);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      this.sockets.clear();\n      this.decoder.destroy(); // clean up decoder\n    }\n    /**\n     * Cleans up event listeners.\n     * @private\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.conn.removeListener(\"data\", this.ondata);\n      this.conn.removeListener(\"error\", this.onerror);\n      this.conn.removeListener(\"close\", this.onclose); // @ts-ignore\n\n      this.decoder.removeListener(\"decoded\", this.ondecoded);\n\n      if (this.connectTimeout) {\n        clearTimeout(this.connectTimeout);\n        this.connectTimeout = undefined;\n      }\n    }\n  }]);\n\n  return Client;\n}();\n\nexports.Client = Client;","map":{"version":3,"sources":["/home/tobias/Documents/test-app/client/node_modules/socket.io/dist/client.js"],"names":["Object","defineProperty","exports","value","Client","socket_io_parser_1","require","debugModule","url","debug","server","conn","sockets","Map","nsps","encoder","decoder","_parser","Decoder","id","setup","request","onclose","bind","ondata","onerror","ondecoded","on","connectTimeout","setTimeout","size","close","_connectTimeout","name","auth","_nsps","has","doConnect","_checkNamespace","dynamicNspName","_packet","type","PacketType","CONNECT_ERROR","nsp","data","message","of","socket","_add","set","clearTimeout","undefined","values","disconnect","clear","get","delete","readyState","packet","opts","self","writeToEngine","encodedPackets","volatile","transport","writable","i","length","write","compress","preEncoded","encode","add","e","CONNECT","protocol","parsed","parse","connect","pathname","query","process","nextTick","_onpacket","err","_onerror","reason","destroy","_onclose","removeListener"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Client = void 0;\nconst socket_io_parser_1 = require(\"socket.io-parser\");\nconst debugModule = require(\"debug\");\nconst url = require(\"url\");\nconst debug = debugModule(\"socket.io:client\");\nclass Client {\n    /**\n     * Client constructor.\n     *\n     * @param server instance\n     * @param conn\n     * @package\n     */\n    constructor(server, conn) {\n        this.sockets = new Map();\n        this.nsps = new Map();\n        this.server = server;\n        this.conn = conn;\n        this.encoder = server.encoder;\n        this.decoder = new server._parser.Decoder();\n        this.id = conn.id;\n        this.setup();\n    }\n    /**\n     * @return the reference to the request that originated the Engine.IO connection\n     *\n     * @public\n     */\n    get request() {\n        return this.conn.request;\n    }\n    /**\n     * Sets up event listeners.\n     *\n     * @private\n     */\n    setup() {\n        this.onclose = this.onclose.bind(this);\n        this.ondata = this.ondata.bind(this);\n        this.onerror = this.onerror.bind(this);\n        this.ondecoded = this.ondecoded.bind(this);\n        // @ts-ignore\n        this.decoder.on(\"decoded\", this.ondecoded);\n        this.conn.on(\"data\", this.ondata);\n        this.conn.on(\"error\", this.onerror);\n        this.conn.on(\"close\", this.onclose);\n        this.connectTimeout = setTimeout(() => {\n            if (this.nsps.size === 0) {\n                debug(\"no namespace joined yet, close the client\");\n                this.close();\n            }\n            else {\n                debug(\"the client has already joined a namespace, nothing to do\");\n            }\n        }, this.server._connectTimeout);\n    }\n    /**\n     * Connects a client to a namespace.\n     *\n     * @param {String} name - the namespace\n     * @param {Object} auth - the auth parameters\n     * @private\n     */\n    connect(name, auth = {}) {\n        if (this.server._nsps.has(name)) {\n            debug(\"connecting to namespace %s\", name);\n            return this.doConnect(name, auth);\n        }\n        this.server._checkNamespace(name, auth, (dynamicNspName) => {\n            if (dynamicNspName) {\n                debug(\"dynamic namespace %s was created\", dynamicNspName);\n                this.doConnect(name, auth);\n            }\n            else {\n                debug(\"creation of namespace %s was denied\", name);\n                this._packet({\n                    type: socket_io_parser_1.PacketType.CONNECT_ERROR,\n                    nsp: name,\n                    data: {\n                        message: \"Invalid namespace\",\n                    },\n                });\n            }\n        });\n    }\n    /**\n     * Connects a client to a namespace.\n     *\n     * @param name - the namespace\n     * @param {Object} auth - the auth parameters\n     *\n     * @private\n     */\n    doConnect(name, auth) {\n        const nsp = this.server.of(name);\n        const socket = nsp._add(this, auth, () => {\n            this.sockets.set(socket.id, socket);\n            this.nsps.set(nsp.name, socket);\n            if (this.connectTimeout) {\n                clearTimeout(this.connectTimeout);\n                this.connectTimeout = undefined;\n            }\n        });\n    }\n    /**\n     * Disconnects from all namespaces and closes transport.\n     *\n     * @private\n     */\n    _disconnect() {\n        for (const socket of this.sockets.values()) {\n            socket.disconnect();\n        }\n        this.sockets.clear();\n        this.close();\n    }\n    /**\n     * Removes a socket. Called by each `Socket`.\n     *\n     * @private\n     */\n    _remove(socket) {\n        if (this.sockets.has(socket.id)) {\n            const nsp = this.sockets.get(socket.id).nsp.name;\n            this.sockets.delete(socket.id);\n            this.nsps.delete(nsp);\n        }\n        else {\n            debug(\"ignoring remove for %s\", socket.id);\n        }\n    }\n    /**\n     * Closes the underlying connection.\n     *\n     * @private\n     */\n    close() {\n        if (\"open\" === this.conn.readyState) {\n            debug(\"forcing transport close\");\n            this.conn.close();\n            this.onclose(\"forced server close\");\n        }\n    }\n    /**\n     * Writes a packet to the transport.\n     *\n     * @param {Object} packet object\n     * @param {Object} opts\n     * @private\n     */\n    _packet(packet, opts) {\n        opts = opts || {};\n        const self = this;\n        // this writes to the actual connection\n        function writeToEngine(encodedPackets) {\n            // TODO clarify this.\n            if (opts.volatile && !self.conn.transport.writable)\n                return;\n            for (let i = 0; i < encodedPackets.length; i++) {\n                self.conn.write(encodedPackets[i], { compress: opts.compress });\n            }\n        }\n        if (\"open\" === this.conn.readyState) {\n            debug(\"writing packet %j\", packet);\n            if (!opts.preEncoded) {\n                // not broadcasting, need to encode\n                writeToEngine(this.encoder.encode(packet)); // encode, then write results to engine\n            }\n            else {\n                // a broadcast pre-encodes a packet\n                writeToEngine(packet);\n            }\n        }\n        else {\n            debug(\"ignoring packet write %j\", packet);\n        }\n    }\n    /**\n     * Called with incoming transport data.\n     *\n     * @private\n     */\n    ondata(data) {\n        // try/catch is needed for protocol violations (GH-1880)\n        try {\n            this.decoder.add(data);\n        }\n        catch (e) {\n            this.onerror(e);\n        }\n    }\n    /**\n     * Called when parser fully decodes a packet.\n     *\n     * @private\n     */\n    ondecoded(packet) {\n        if (socket_io_parser_1.PacketType.CONNECT === packet.type) {\n            if (this.conn.protocol === 3) {\n                const parsed = url.parse(packet.nsp, true);\n                this.connect(parsed.pathname, parsed.query);\n            }\n            else {\n                this.connect(packet.nsp, packet.data);\n            }\n        }\n        else {\n            const socket = this.nsps.get(packet.nsp);\n            if (socket) {\n                process.nextTick(function () {\n                    socket._onpacket(packet);\n                });\n            }\n            else {\n                debug(\"no socket for namespace %s\", packet.nsp);\n            }\n        }\n    }\n    /**\n     * Handles an error.\n     *\n     * @param {Object} err object\n     * @private\n     */\n    onerror(err) {\n        for (const socket of this.sockets.values()) {\n            socket._onerror(err);\n        }\n        this.conn.close();\n    }\n    /**\n     * Called upon transport close.\n     *\n     * @param reason\n     * @private\n     */\n    onclose(reason) {\n        debug(\"client close with reason %s\", reason);\n        // ignore a potential subsequent `close` event\n        this.destroy();\n        // `nsps` and `sockets` are cleaned up seamlessly\n        for (const socket of this.sockets.values()) {\n            socket._onclose(reason);\n        }\n        this.sockets.clear();\n        this.decoder.destroy(); // clean up decoder\n    }\n    /**\n     * Cleans up event listeners.\n     * @private\n     */\n    destroy() {\n        this.conn.removeListener(\"data\", this.ondata);\n        this.conn.removeListener(\"error\", this.onerror);\n        this.conn.removeListener(\"close\", this.onclose);\n        // @ts-ignore\n        this.decoder.removeListener(\"decoded\", this.ondecoded);\n        if (this.connectTimeout) {\n            clearTimeout(this.connectTimeout);\n            this.connectTimeout = undefined;\n        }\n    }\n}\nexports.Client = Client;\n"]},"metadata":{},"sourceType":"script"}