{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/tobias/Documents/test-app/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/tobias/Documents/test-app/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RemoteSocket = exports.BroadcastOperator = void 0;\n\nvar socket_1 = require(\"./socket\");\n\nvar socket_io_parser_1 = require(\"socket.io-parser\");\n\nvar BroadcastOperator = /*#__PURE__*/function () {\n  function BroadcastOperator(adapter) {\n    var rooms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n    var exceptRooms = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n    var flags = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    _classCallCheck(this, BroadcastOperator);\n\n    this.adapter = adapter;\n    this.rooms = rooms;\n    this.exceptRooms = exceptRooms;\n    this.flags = flags;\n  }\n  /**\n   * Targets a room when emitting.\n   *\n   * @param room\n   * @return a new BroadcastOperator instance\n   * @public\n   */\n\n\n  _createClass(BroadcastOperator, [{\n    key: \"to\",\n    value: function to(room) {\n      var rooms = new Set(this.rooms);\n\n      if (Array.isArray(room)) {\n        room.forEach(function (r) {\n          return rooms.add(r);\n        });\n      } else {\n        rooms.add(room);\n      }\n\n      return new BroadcastOperator(this.adapter, rooms, this.exceptRooms, this.flags);\n    }\n    /**\n     * Targets a room when emitting.\n     *\n     * @param room\n     * @return a new BroadcastOperator instance\n     * @public\n     */\n\n  }, {\n    key: \"in\",\n    value: function _in(room) {\n      return this.to(room);\n    }\n    /**\n     * Excludes a room when emitting.\n     *\n     * @param room\n     * @return a new BroadcastOperator instance\n     * @public\n     */\n\n  }, {\n    key: \"except\",\n    value: function except(room) {\n      var exceptRooms = new Set(this.exceptRooms);\n\n      if (Array.isArray(room)) {\n        room.forEach(function (r) {\n          return exceptRooms.add(r);\n        });\n      } else {\n        exceptRooms.add(room);\n      }\n\n      return new BroadcastOperator(this.adapter, this.rooms, exceptRooms, this.flags);\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return a new BroadcastOperator instance\n     * @public\n     */\n\n  }, {\n    key: \"compress\",\n    value: function compress(_compress) {\n      var flags = Object.assign({}, this.flags, {\n        compress: _compress\n      });\n      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because they’re connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @return a new BroadcastOperator instance\n     * @public\n     */\n\n  }, {\n    key: \"volatile\",\n    get: function get() {\n      var flags = Object.assign({}, this.flags, {\n        volatile: true\n      });\n      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @return a new BroadcastOperator instance\n     * @public\n     */\n\n  }, {\n    key: \"local\",\n    get: function get() {\n      var flags = Object.assign({}, this.flags, {\n        local: true\n      });\n      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Emits to all clients.\n     *\n     * @return Always true\n     * @public\n     */\n\n  }, {\n    key: \"emit\",\n    value: function emit(ev) {\n      if (socket_1.RESERVED_EVENTS.has(ev)) {\n        throw new Error(\"\\\"\".concat(ev, \"\\\" is a reserved event name\"));\n      } // set up packet object\n\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      var data = [ev].concat(args);\n      var packet = {\n        type: socket_io_parser_1.PacketType.EVENT,\n        data: data\n      };\n\n      if (\"function\" == typeof data[data.length - 1]) {\n        throw new Error(\"Callbacks are not supported when broadcasting\");\n      }\n\n      this.adapter.broadcast(packet, {\n        rooms: this.rooms,\n        except: this.exceptRooms,\n        flags: this.flags\n      });\n      return true;\n    }\n    /**\n     * Gets a list of clients.\n     *\n     * @public\n     */\n\n  }, {\n    key: \"allSockets\",\n    value: function allSockets() {\n      if (!this.adapter) {\n        throw new Error(\"No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?\");\n      }\n\n      return this.adapter.sockets(this.rooms);\n    }\n    /**\n     * Returns the matching socket instances\n     *\n     * @public\n     */\n\n  }, {\n    key: \"fetchSockets\",\n    value: function fetchSockets() {\n      var _this = this;\n\n      return this.adapter.fetchSockets({\n        rooms: this.rooms,\n        except: this.exceptRooms\n      }).then(function (sockets) {\n        return sockets.map(function (socket) {\n          if (socket instanceof socket_1.Socket) {\n            // FIXME the TypeScript compiler complains about missing private properties\n            return socket;\n          } else {\n            return new RemoteSocket(_this.adapter, socket);\n          }\n        });\n      });\n    }\n    /**\n     * Makes the matching socket instances join the specified rooms\n     *\n     * @param room\n     * @public\n     */\n\n  }, {\n    key: \"socketsJoin\",\n    value: function socketsJoin(room) {\n      this.adapter.addSockets({\n        rooms: this.rooms,\n        except: this.exceptRooms\n      }, Array.isArray(room) ? room : [room]);\n    }\n    /**\n     * Makes the matching socket instances leave the specified rooms\n     *\n     * @param room\n     * @public\n     */\n\n  }, {\n    key: \"socketsLeave\",\n    value: function socketsLeave(room) {\n      this.adapter.delSockets({\n        rooms: this.rooms,\n        except: this.exceptRooms\n      }, Array.isArray(room) ? room : [room]);\n    }\n    /**\n     * Makes the matching socket instances disconnect\n     *\n     * @param close - whether to close the underlying connection\n     * @public\n     */\n\n  }, {\n    key: \"disconnectSockets\",\n    value: function disconnectSockets() {\n      var close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      this.adapter.disconnectSockets({\n        rooms: this.rooms,\n        except: this.exceptRooms\n      }, close);\n    }\n  }]);\n\n  return BroadcastOperator;\n}();\n\nexports.BroadcastOperator = BroadcastOperator;\n/**\n * Expose of subset of the attributes and methods of the Socket class\n */\n\nvar RemoteSocket = /*#__PURE__*/function () {\n  function RemoteSocket(adapter, details) {\n    _classCallCheck(this, RemoteSocket);\n\n    this.id = details.id;\n    this.handshake = details.handshake;\n    this.rooms = new Set(details.rooms);\n    this.data = details.data;\n    this.operator = new BroadcastOperator(adapter, new Set([this.id]));\n  }\n\n  _createClass(RemoteSocket, [{\n    key: \"emit\",\n    value: function emit(ev) {\n      var _this$operator;\n\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      return (_this$operator = this.operator).emit.apply(_this$operator, [ev].concat(args));\n    }\n    /**\n     * Joins a room.\n     *\n     * @param {String|Array} room - room or array of rooms\n     * @public\n     */\n\n  }, {\n    key: \"join\",\n    value: function join(room) {\n      return this.operator.socketsJoin(room);\n    }\n    /**\n     * Leaves a room.\n     *\n     * @param {String} room\n     * @public\n     */\n\n  }, {\n    key: \"leave\",\n    value: function leave(room) {\n      return this.operator.socketsLeave(room);\n    }\n    /**\n     * Disconnects this client.\n     *\n     * @param {Boolean} close - if `true`, closes the underlying connection\n     * @return {Socket} self\n     *\n     * @public\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      var close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      this.operator.disconnectSockets(close);\n      return this;\n    }\n  }]);\n\n  return RemoteSocket;\n}();\n\nexports.RemoteSocket = RemoteSocket;","map":{"version":3,"sources":["/home/tobias/Documents/test-app/client/node_modules/socket.io/dist/broadcast-operator.js"],"names":["Object","defineProperty","exports","value","RemoteSocket","BroadcastOperator","socket_1","require","socket_io_parser_1","adapter","rooms","Set","exceptRooms","flags","room","Array","isArray","forEach","r","add","to","compress","assign","volatile","local","ev","RESERVED_EVENTS","has","Error","args","data","packet","type","PacketType","EVENT","length","broadcast","except","sockets","fetchSockets","then","map","socket","Socket","addSockets","delSockets","close","disconnectSockets","details","id","handshake","operator","emit","socketsJoin","socketsLeave"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RemoteSocket = exports.BroadcastOperator = void 0;\nconst socket_1 = require(\"./socket\");\nconst socket_io_parser_1 = require(\"socket.io-parser\");\nclass BroadcastOperator {\n    constructor(adapter, rooms = new Set(), exceptRooms = new Set(), flags = {}) {\n        this.adapter = adapter;\n        this.rooms = rooms;\n        this.exceptRooms = exceptRooms;\n        this.flags = flags;\n    }\n    /**\n     * Targets a room when emitting.\n     *\n     * @param room\n     * @return a new BroadcastOperator instance\n     * @public\n     */\n    to(room) {\n        const rooms = new Set(this.rooms);\n        if (Array.isArray(room)) {\n            room.forEach((r) => rooms.add(r));\n        }\n        else {\n            rooms.add(room);\n        }\n        return new BroadcastOperator(this.adapter, rooms, this.exceptRooms, this.flags);\n    }\n    /**\n     * Targets a room when emitting.\n     *\n     * @param room\n     * @return a new BroadcastOperator instance\n     * @public\n     */\n    in(room) {\n        return this.to(room);\n    }\n    /**\n     * Excludes a room when emitting.\n     *\n     * @param room\n     * @return a new BroadcastOperator instance\n     * @public\n     */\n    except(room) {\n        const exceptRooms = new Set(this.exceptRooms);\n        if (Array.isArray(room)) {\n            room.forEach((r) => exceptRooms.add(r));\n        }\n        else {\n            exceptRooms.add(room);\n        }\n        return new BroadcastOperator(this.adapter, this.rooms, exceptRooms, this.flags);\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return a new BroadcastOperator instance\n     * @public\n     */\n    compress(compress) {\n        const flags = Object.assign({}, this.flags, { compress });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because they’re connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @return a new BroadcastOperator instance\n     * @public\n     */\n    get volatile() {\n        const flags = Object.assign({}, this.flags, { volatile: true });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @return a new BroadcastOperator instance\n     * @public\n     */\n    get local() {\n        const flags = Object.assign({}, this.flags, { local: true });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Emits to all clients.\n     *\n     * @return Always true\n     * @public\n     */\n    emit(ev, ...args) {\n        if (socket_1.RESERVED_EVENTS.has(ev)) {\n            throw new Error(`\"${ev}\" is a reserved event name`);\n        }\n        // set up packet object\n        const data = [ev, ...args];\n        const packet = {\n            type: socket_io_parser_1.PacketType.EVENT,\n            data: data,\n        };\n        if (\"function\" == typeof data[data.length - 1]) {\n            throw new Error(\"Callbacks are not supported when broadcasting\");\n        }\n        this.adapter.broadcast(packet, {\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags,\n        });\n        return true;\n    }\n    /**\n     * Gets a list of clients.\n     *\n     * @public\n     */\n    allSockets() {\n        if (!this.adapter) {\n            throw new Error(\"No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?\");\n        }\n        return this.adapter.sockets(this.rooms);\n    }\n    /**\n     * Returns the matching socket instances\n     *\n     * @public\n     */\n    fetchSockets() {\n        return this.adapter\n            .fetchSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n        })\n            .then((sockets) => {\n            return sockets.map((socket) => {\n                if (socket instanceof socket_1.Socket) {\n                    // FIXME the TypeScript compiler complains about missing private properties\n                    return socket;\n                }\n                else {\n                    return new RemoteSocket(this.adapter, socket);\n                }\n            });\n        });\n    }\n    /**\n     * Makes the matching socket instances join the specified rooms\n     *\n     * @param room\n     * @public\n     */\n    socketsJoin(room) {\n        this.adapter.addSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n        }, Array.isArray(room) ? room : [room]);\n    }\n    /**\n     * Makes the matching socket instances leave the specified rooms\n     *\n     * @param room\n     * @public\n     */\n    socketsLeave(room) {\n        this.adapter.delSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n        }, Array.isArray(room) ? room : [room]);\n    }\n    /**\n     * Makes the matching socket instances disconnect\n     *\n     * @param close - whether to close the underlying connection\n     * @public\n     */\n    disconnectSockets(close = false) {\n        this.adapter.disconnectSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n        }, close);\n    }\n}\nexports.BroadcastOperator = BroadcastOperator;\n/**\n * Expose of subset of the attributes and methods of the Socket class\n */\nclass RemoteSocket {\n    constructor(adapter, details) {\n        this.id = details.id;\n        this.handshake = details.handshake;\n        this.rooms = new Set(details.rooms);\n        this.data = details.data;\n        this.operator = new BroadcastOperator(adapter, new Set([this.id]));\n    }\n    emit(ev, ...args) {\n        return this.operator.emit(ev, ...args);\n    }\n    /**\n     * Joins a room.\n     *\n     * @param {String|Array} room - room or array of rooms\n     * @public\n     */\n    join(room) {\n        return this.operator.socketsJoin(room);\n    }\n    /**\n     * Leaves a room.\n     *\n     * @param {String} room\n     * @public\n     */\n    leave(room) {\n        return this.operator.socketsLeave(room);\n    }\n    /**\n     * Disconnects this client.\n     *\n     * @param {Boolean} close - if `true`, closes the underlying connection\n     * @return {Socket} self\n     *\n     * @public\n     */\n    disconnect(close = false) {\n        this.operator.disconnectSockets(close);\n        return this;\n    }\n}\nexports.RemoteSocket = RemoteSocket;\n"]},"metadata":{},"sourceType":"script"}